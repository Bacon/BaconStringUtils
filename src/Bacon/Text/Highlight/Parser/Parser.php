<?php
/**
 * Bacon.
 *
 * LICENSE
 *
 * This source file is subject to the new BSD license that is bundled
 * with this package in the file LICENSE.txt.
 * If you did not receive a copy of the license and are unable to
 * obtain it through the world-wide-web, please send an email
 * to mail@dasprids.de so I can send you a copy immediately.
 *
 * @category   Bacon
 * @package    Bacon_Text
 * @subpackage Highlight
 * @copyright  Copyright (c) 2011 Ben Scholzen <mail@dasprids.de>
 * @license    New BSD License
 */

/**
 * @namespace
 */
namespace Bacon\Text\Highlight\Parser;

use Bacon\Text\Highlight\Generator\Generator;

/**
 * Source code parser.
 * 
 * @category   Bacon
 * @package    Bacon_Text
 * @subpackage Highlight
 * @copyright  Copyright (c) 2011 Ben Scholzen <mail@dasprids.de>
 * @license    New BSD License
 */
class Parser
{
    /**
     * Current syntax.
     * 
     * @var Syntax
     */
    protected $currentSyntax;
    
    /**
     * Current state.
     * 
     * @var integer
     */
    protected $currentState;
    
    /**
     * Whitespace buffer.
     *  
     * @var string
     */
    protected $whitespaceBuffer;
    
    /**
     * Loaded syntaxes.
     * 
     * @var array
     */
    protected $syntaxes = array();
    
    /**
     * Regex groups.
     * 
     * @var array
     */
    protected $regexGroups;
    
    /**
     * Current line.
     * 
     * @var string
     */
    protected $line;
    
    /**
     * Current line number.
     * 
     * @var integer
     */
    protected $lineNumber;
    
    /**
     * Current line index.
     * 
     * @var integer
     */
    protected $lineIndex;
    
    /**
     * Current token.
     * 
     * @var string
     */
    protected $token;
    
    /**
     * Data generated by the parser.
     * 
     * @var array
     */
    protected $data;
    
    /**
     * Input stream.
     * 
     * @var resource
     */
    protected $input;
    
    /**
     * Host language.
     * 
     * @var string
     */
    protected $hostLanguage;
    
    /**
     * Parse a source stream.
     * 
     * @param  resource $input
     * @param  string   $language
     * @return array
     */
    public function parse($input, $language)
    {
        if (!is_resource($input)) {
            throw new Exception\InvalidArgumentException('Input is not a valid resource');
        }
        
        $this->whitespaceBuffer = '';
        $this->regexGroups      = array();
        $this->line             = 0;
        $this->lineIndex        = 0;
        $this->lineNumber       = 0;
        
        $this->data  = array();
        $this->input = $input;
        
        $this->loadLanguage($language);
        $this->processRootState();
        
        return $this->data;
    }
    
    /**
     * Load a language.
     * 
     * @param  string $language
     * @return void
     */
    protected function loadLanguage($language)
    {
        if (!isset($this->syntaxes[$language])) {
            $this->syntaxes[$language] = new Syntax($language);
        }
        
        $this->currentSyntax = $this->syntaxes[$language];
    }
    
    /**
     * Load an embedded language.
     * 
     * @param  string $language
     * @return void
     */
    protected function loadEmbeddedLanguage($language)
    {
        if ($this->hostLanguage === null) {
            $this->hostLanguage = '';
        }
        
        $this->loadLanguage($language);
        
        // @todo
    }
    
    /**
     * Get an input character.
     * 
     * @return string
     */
    protected function getInputChar()
    {
        $eol = ($this->lineIndex === strlen($this->line));
        
        if ($eol) {
            $eof = $this->readNewLine();
            
            $this->lineIndex = 0;
            $this->lineNumber++;
            
            $this->matchRegex();
            
            return ($eof ? "\0" : "\n");
        }
        
        return $this->line[$this->lineIndex++];
    }
    
    /**
     * Match a regex on the current line.
     * 
     * @return void
     */
    protected function matchRegex()
    {
        $this->regexGroups = array();
        $matchBegin        = 0;
        $matchLength       = 0;
        $groupId           = 0;
        $regexElements     = $this->currentSyntax->getRegexElements();
        $numElements       = count($regexElements);
        var_dump($regexElements);
        for ($i = 0; $i < $numElements; $i++) {
            $element = $regexElements[$i];
        }
    }
    
    /**
     * Read a new line.
     * 
     * @param  string $newLine
     * @return boolean
     */
    protected function readNewLine()
    {
        if ($this->lineIndex) {
            $this->terminatingChar = $this->line[$this->lineIndex - 1];
        }
        
        $this->line = fgets($this->input);
        $eof        = ($this->line === false);
        
        return $eof;
    }
    
    /**
     * Flush whitespace.
     * 
     * @return 
     */
    protected function flushWhitespaceBuffer()
    {
        $this->data[]           = array('whitespace', $this->whitespaceBuffer);
        $this->whitespaceBuffer = '';
    }
    
    /**
     * Append line number.
     * 
     * @param  boolean $insertNewLine
     * @return void
     */
    protected function appendLineNumber($insertNewLine = true)
    {
        if ($insertNewLine) {
            $this->flushWhitespaceBuffer();
            
            $this->data[] = array('newline');
        }
        
        $this->data[] = array('line_number', $this->lineNumber);
    }
    
    /**
     * Append a masked token.
     * 
     * @param boolean $addMetaInfo
     * @param boolean $flushWhiteSpace
     * @param string  $case 
     */
    protected function appendMaskedToken($addMetaInfo = false, $flushWhiteSpace = true)
    {
        if ($flushWhiteSpace) {
            $this->flushWhitespaceBuffer();
        }
        
        if ($addMetaInfo) {
            // @todo do we need this? Check back later.
            $this->data[] = array('token', $this->token);
        } else {
            $this->data[] = array('token', $this->token);
        }
        
        $this->token = '';
    }
    
    /**
     * Open a tag.
     * 
     * @param  integer $state
     * @return void
     */
    public function openTag($state)
    {
        $this->data[]       = array('open_tag', $state);
        $this->currentState = $state;
    }

    /**
     * Close a tag.
     * 
     * @param  integer $state
     * @return void
     */
    public function closeTag($state)
    {
        $this->data[]       = array('close_tag', $state);
        $this->currentState = States::_UNKNOWN;
        
        $this->flushWhitespaceBuffer();
    }
    
    /**
     * Open a keyword tag.
     * 
     * @param  integer $keywordClass
     * @return void
     */
    public function openKeywordTag($keywordClass)
    {
        $this->data[]       = array('open_keyword_tag', $keywordClass);
        $this->currentState = States::KEYWORD;
    }

    /**
     * Close a keyword tag.
     * 
     * @param  integer $keywordClass
     * @return void
     */
    public function closeKeywordTag($keywordClass)
    {
        $this->data[]       = array('close_keyword_tag', $keywordClass);
        $this->currentState = States::_UNKNOWN;

        $this->flushWhitespaceBuffer();
    }
       
    /**
     * Get the current state.
     * 
     * @param integer $oldState
     */
    protected function getCurrentState($oldState)
    {
        $char = "\0";
        
        if (strlen($this->token) === 0) {
            $char = $this->getInputChar();
        } else {
            $this->lineIndex -= (strlen($this->token) - 1);
            $char             = $this->token[0];
        }
        
        if ($char === "\n") {
            return States::_EOL;
        } elseif ($char === "\0") {
            return States::_EOF;
        } elseif ($char === ' ' || $char === "\t") {
            $this->token = $char;
            return States::_WS;
        }
        
        if ($this->regexGroups) {
            $this->token = substr($this->line, $this->lineIndex - 1, $this->regexGroups[$this->lineIndex]['length']);
            $oldIndex    = $this->lineIndex;
            
            if (count($this->regexGroups[$oldIndex]) > 1) {
                $this->lineIndex += count($this->regexGroups) - 1;
            }
            
            if ($this->regexGroups[$oldIndex].getState() === States::EMBEDDED_CODE_BEGIN) {
                $this->embedLanguageDefinitionPath = $this->currentSyntax->getNewPath($this->regexGroups[$oldIndex]['name']);
            }
            
            if ($this->regexGroups[$oldIndex]['state'] === States::IDENTIFIER_BEGIN || $this->regexGroups[$oldIndex]['state'] === States::KEYWORD) {
                $reservedWord        = ($this->currentSyntax->shouldIgnoreCase() ? strtolower($this->token) : $this->token);
                $currentKeywordClass = $this->currentSyntax->isKeyword($reservedWord);
                
                if (!$currentKeywordClass && $this->regexGroups[$oldIndex]['state'] === States::KEYWORD) {
                    $currentKeywordClass = $this->regexGroups[$oldIndex]['keyword_class'];
                }

                return $this->validateState($currentKeywordClass ? States::KEYWORD : States::STANDARD, $oldState, $currentKeywordClass);
            } else {
                return $this->validateState($this->regexGroups[$oldIndex]['state'], $oldState, 0);
            }
        }
        
        $this->token = $char;
        
        return States::STANDARD;
    }
    
    /**
     * Validate the state through the current syntax.
     * 
     * @param  integer $newState
     * @param  integer $oldState
     * @param  integer $keywordClass
     * @return integer
     */
    protected function validateState($newState, $oldState, $keywordClass)
    {
        if (null !== ($function = $this->currentSyntax->validateStateChangeFunction())) {
            return $function($oldState, $newState, $this->token, $keywordClass);
        }
        
        return $newState;
    }
    
    /**
     * Process the root state.
     * 
     * @return void
     */
    protected function processRootState()
    {
        $eof       = false;
        $firstLine = true;
        
        $this->openTag(States::STANDARD);
        
        do {
            $state = $this->getCurrentState(States::STANDARD);

            switch ($state) {
                case States::KEYWORD:
                    $this->closeTag(States::STANDARD);
                    $eof = $this->processKeywordState($state);
                    $this->openTag(States::STANDARD);
                    break;
                
                case States::NUMBER:
                    $this->closeTag(States::STANDARD);
                    $eof = $this->processNumberState();
                    $this->openTag(States::STANDARD);
                    break;
                
                case States::ML_COMMENT:
                    $this->closeTag(States::STANDARD);
                    $eof = $this->processMultiLineCommentState();
                    $this->openTag(States::STANDARD);
                    break;
                
                case States::SL_COMMENT:
                    $this->closeTag(States::STANDARD);
                    $eof = $this->processSingleLineState();
                    $this->openTag(States::STANDARD);
                    break;
                
                case States::STRING:
                    $this->closeTag(States::STANDARD);
                    $eof = $this->processStringState(States::STANDARD);
                    $this->openTag(States::STANDARD);
                    break;
                
                case States::DIRECTIVE:
                    $this->closeTag(States::STANDARD);
                    $eof = $this->processDirectiveState();
                    $this->openTag(States::STANDARD);
                    break;
                
                case States::ESC_CHAR:
                    $this->closeTag(States::STANDARD);
                    $eof = $this->processEscapeCharState();
                    $this->openTag(States::STANDARD);
                    break;
                
                case States::SYMBOL:
                    $this->closeTag(States::STANDARD);
                    $eof = $this->processSymbolState();
                    $this->openTag(States::STANDARD);
                    break;
                
                case States::EMBEDDED_CODE_BEGIN:
                case States::EMBEDDED_CODE_END:
                    $this->closeTag(States::STANDARD);
                    $eof = $this->processSyntaxChangeState($state);
                    $this->openTag(States::STANDARD);
                    break;
                
                case States::_EOL:
                    $this->appendLineNumber(!$firstLine);
                    $firstLine = false;
                    break;
                
                case States::_EOF:
                    $eof = true;
                    break;
                
                case States::_WS:
                    $this->processWhitespaceState();
                    break;
                
                default:
                    $this->appendMaskedToken(true);
                    break;
            }
        } while (!$eof);
        
        $this->closeTag(States::STANDARD);
        
        $this->data[] = array('newline');
    }
    
    /**
     * Process a syntax change state.
     * 
     * @param  integer $state
     * @return boolean
     */
    protected function processSyntaxChangeState($state)
    {
        $newState  = States::STANDARD;
        $eof       = false;
        $exitState = false;
        
        $this->openTag(States::KEYWORD);
        
        do {
            if ($state === States::EMBEDDED_CODE_BEGIN) {
                $this->loadEmbeddedLanguage($languagePath);
                $this->matchRegex($this->line);
            } elseif ($state === States::EMBEDDED_CODE_END) {
                $this->loadLanguage($this->hostLanguage);
                $this->matchRegex($this->line);
            }
            
            $this->appendMaskedToken(false, $newState !== States::_WS);
            $newState = $this->getCurrentState($state);
            
            switch ($newState) {
                case States::_WS:
                    $this->processWhitespaceState();
                    break;
                
                case States::_EOL:
                    $this->appendLineNumber();
                    $exitState = true;
                    break;
                
                case States::_EOF:
                    $eof = true;
                    break;
                
                default:
                    $exitState = true;
                    break;
            }
        } while (!$exitState && !$eof);
        
        $this->closeTag(States::KEYWORD);
        
        return $eof;
    }
    
    /**
     * Process a keyword state.
     * 
     * @param  integer $state
     * @return boolean
     */
    protected function processKeywordState($state)
    {
        $newState     = States::STANDARD;
        $keywordClass = $this->currentKeywordClass;
        $eof          = false;
        $exitState    = false;
        
        $this->openKeywordTag($keywordClass);
        
        do {
            $this->appendMaskedToken(true, $newState !== States::_WS);
            $newState = $this->getCurrentState($state);
            
            switch ($newState) {
                case States::_WS:
                    $this->processWhitespaceState();
                    break;
                
                case States::_EOL:
                    $this->appendLineNumber();
                    $exitState = true;
                    break;
                
                case States::_EOF:
                    $eof = true;
                    break;
                
                default:
                    $exitState = ($keywordClass !== $this->currentKeywordClass || $state !== $newState);
                    break;
            }
        } while (!$exitState && !$eof);
        
        $this->closeKeywordTag($keywordClass);
        
        $this->currentKeywordClass = null;
        
        return $eof;
    }
    
    /**
     * Process a number state.
     * 
     * @return boolean
     */
    protected function processNumberState()
    {
        $newState  = States::STANDARD;
        $eof       = false;
        $exitState = false;
        
        $this->openTag(States::NUMBER);
        
        do {
            $this->appendMaskedToken(false, $newState !== States::_WS);
            $newState = $this->getCurrentState(States::NUMBER);
            
            switch ($newState) {
                case States::_WS:
                    $this->processWhitespaceState();
                    break;
                
                case States::_EOL:
                    $this->appendLineNumber();
                    $exitState = true;
                    break;
                
                case States::_EOF:
                    $eof = true;
                    break;
                
                default:
                    $exitState = ($newState !== States::NUMBER);
                    break;
            }
        } while (!$exitState && !$eof);
        
        $this->closeTag(States::NUMBER);
        
        return $eof;
    }
    
    /**
     * Process a multi-line comment state.
     * 
     * @return boolean
     */
    protected function processMultiLineCommentState()
    {
        $commentCount    = 1;
        $openDelimiterId = $this->currentSyntax->getOpenDelimiterId($this->token, States::ML_COMMENT);
        $newState        = States::STANDARD;
        $eof             = false;
        $exitState       = false;
        
        $this->openTag(States::ML_COMMENT);
        
        do {
            $this->appendMaskedToken(false, $newState !== States::_WS);
            $newState = $this->getCurrentState(States::ML_COMMENT);
            
            switch ($newState) {
                case States::_WS:
                    $this->processWhitespaceState();
                    break;
                
                case States::_EOL:
                    $this->appendLineNumber();
                    break;
                
                case States::_EOF:
                    $eof = true;
                    break;
                
                case States::ML_COMMENT:
                    if ($this->currentSyntax->allowsNestedMultiLineComments()) {
                        $commentCount++;
                    }
                    
                    // If delimiters are equal, close the comment by continueing
                    // to ML_COMMENT_END section.
                    if ($this->currentSyntax->delimiterIsDistinct($this->currentSyntax->getOpenDelimiterId($this->token, States::ML_COMMENT))) {
                        break;
                    }
                    
                case States::ML_COMMENT_END:
                    if (!$this->currentSyntax->matchesOpenDelimiter($this->token, States::ML_COMMENT_END, $openDelimiterId)) {
                        break;
                    }
                    
                    $commentCount--;
                    
                    if ($commentCount === 0) {
                        $this->appendMaskedToken();
                        $exitState = true;
                    }
                    break;
                
                default:
                    break;
            }
        } while (!$exitState && !$eof);
        
        $this->closeTag(States::ML_COMMENT);
        
        return $eof;
    }
    
    /**
     * Process a single-line comment state.
     * 
     * @return boolean
     */
    protected function processSingleLineCommentState()
    {
        $newState  = States::STANDARD;
        $eof       = false;
        $exitState = false;
        
        $this->openTag(States::SL_COMMENT);
        
        do {
            $this->appendMaskedToken(false, $newState !== States::_WS);
            $newState = $this->getCurrentState(States::SL_COMMENT);
            
            switch ($newState) {
                case States::_WS:
                    $this->processWhitespaceState();
                    break;
                
                case States::_EOL:
                    $this->appendMaskedToken();
                    $exitState = true;
                                       
                    $this->appendLineNumber();
                    break;
                
                case States::_EOF:
                    $eof = true;
                    break;
                
                default:
                    break;
            }
        } while (!$exitState && !$eof);
        
        $this->closeTag(States::SL_COMMENT);
        
        return $eof;
    }
    
    /**
     * Process a directive state.
     * 
     * @return boolean
     */
    protected function processDirectiveState()
    {
        $newState  = States::STANDARD;
        $eof       = false;
        $exitState = false;
        
        $this->openTag(States::DIRECTIVE);
        
        do {
            $this->appendMaskedToken(false, $newState !== States::_WS);
            $newState = $this->getCurrentState(States::DIRECTIVE);
            
            switch ($newState) {
                case States::_WS:
                    $this->processWhitespaceState();
                    break;
                
                case States::DIRECTIVE_END:
                    $this->appendMaskedToken();
                    $exitState = true;
                    break;
                
                case States::_EOL:
                    $this->appendMaskedToken();
                    $this->appendLineNumber();
                    
                    $exitState = ($this->terminatingChar !== $this->currentSyntax->getContinuationChar());
                    break;
                
                case States::ML_COMMENT:
                    $this->closeTag(States::DIRECTIVE);
                    
                    $eof = $this->processMultiLineCommentState();
                    
                    $this->openTag(States::DIRECTIVE);
                    break;
                
                case States::SL_COMMENT:
                    $this->closeTag(States::DIRECTIVE);
                    
                    $eof       = $this->processSingleLineCommentState();
                    $exitState = true;
                    
                    $this->openTag(States::DIRECTIVE);
                    break;
                
                case States::STRING:
                    $this->closeTag(States::DIRECTIVE);
                    
                    $eof = $this->processStringState();
                    
                    $this->openTag(States::DIRECTIVE);
                    break;
                
                case States::_EOF:
                    $eof = true;
                    break;
                
                default:
                    break;
            }
        } while (!$exitState && !$eof);
        
        $this->closeTag(States::SL_COMMENT);
        
        return $eof;
    }
    
    /**
     * Process a string state.
     * 
     * @param  integer $state
     * @return boolean
     */
    protected function processStringState($state)
    {
        $newState               = States::STANDARD;
        $eof                    = false;
        $exitState              = false;
        $returnedFromOtherState = false;
        
        $state                = ($state === States::DIRECTIVE ? States::DIRECTIVE_STRING : States::STRING);
        $openDelimiterId      = $this->currentSyntax->getOpenDelimiterId($this->token, $state);
        $this->topenDelimiter = $this->token;
        $isRawString          = $this->currentSyntax->delimiterIsRawString($openDelimiterId);
        
        if ($this->lineIndex > strlen($this->token) && $this->line[$this->lineIndex - strlen($this->token) - 1] === $this->currentSyntax->getRawStringPrefix()) {
            $isRawString = true;
        }
        
        $this->openTag($state);
        
        do {
            if ($returnedFromOtherState) {
                $this->appendMaskedToken(false, $newState !== States::_WS);
            }
            
            $newState = $this->getCurrentState($state);
            
            switch ($newState) {
                case States::_WS:
                    $this->processWhitespaceState();
                    break;
                
                case States::_EOL:
                    $this->flushWhitespaceBuffer();
                    $this->closeTag($state);
                    
                    $this->appendLineNumber();
                    
                    $this->flushWhitespaceBuffer();
                    $this->openTag($state);
                    break;
                
                case States::STRING_END:
                    if ($this->currentSyntax->matchesOpenDelimiter($this->token, States::STRING_END, $openDelimiterId)) {
                        $exitState = true;
                        $this->appendMaskedToken();
                    }
                    break;
                    
                case States::STRING:
                    $exitState = $this->currentSyntax->delimiterIsDistinct($this->currentSyntax->getOpenDelimiterId($this->token, States::STRING)) && $this->token === $openDelimiterId;
                    $this->appendMaskedToken();
                    break;
                
                case States::ESC_CHAR:
                    if (!$isRawString) {
                        $this->closeTag($state);
                        
                        $eof = $this->processEscapeCharState();
                        
                        $this->openTag($state);
                        
                        $returnedFromOtherState = true;
                    }
                    break;
                
                case States::_EOF:
                    $eof = true;
                    break;
                
                default:
                    $this->appendMaskedToken();
                    break;
            }
        } while (!$exitState && !$eof);
        
        $this->closeTag(States::SL_COMMENT);
        
        return $eof;
    }
    
    /**
     * Process a symbol state.
     * 
     * @return boolean
     */
    protected function processSymbolState()
    {
        $newState  = States::STANDARD;
        $eof       = false;
        $exitState = false;
        
        $this->openTag(States::SYMBOL);
        
        do {
            $this->appendMaskedToken(false, $newState !== States::_WS);
            $newState = $this->getCurrentState(States::SYMBOL);
            
            switch ($newState) {
                case States::_WS:
                    $this->processWhitespaceState();
                    break;
                
                case States::_EOL:
                    $this->appendLineNumber();
                    $exitState = true;
                    break;
                
                case States::_EOF:
                    $eof = true;
                    break;
                
                default:
                    $exitState = ($newState !== States::SYMBOL);
                    break;
            }
        } while (!$exitState && !$eof);
        
        $this->closeTag(States::SYMBOL);
        
        return $eof;
    }
    
    /**
     * Process an escape char state.
     * 
     * @return boolean
     */
    protected function processEscapeCharState()
    {
        $newState  = States::STANDARD;
        $eof       = false;
        $exitState = false;
        
        $this->openTag(States::ESC_CHAR);
        
        do {
            $this->appendMaskedToken(false, $newState !== States::_WS);
            $newState = $this->getCurrentState(States::ESC_CHAR);
            
            switch ($newState) {
                case States::_WS:
                    $this->processWhitespaceState();
                    break;
                
                case States::_EOL:
                    $this->appendLineNumber();
                    $exitState = true;
                    break;
                
                case States::_EOF:
                    $eof = true;
                    break;
                
                default:
                    $exitState = ($newState !== States::ESC_CHAR);
                    break;
            }
        } while (!$exitState && !$eof);
        
        $this->closeTag(States::ESC_CHAR);
        
        return $eof;
    }
    
    /**
     * Process a whitespace state.
     * 
     * @return void
     */
    protected function processWhitespaceState()
    {
        $this->flushWhitespaceBuffer();
        
        $whitespaceCount = 0;
        $this->lineIndex--;
        
        while ($this->line[$this->lineIndex] === ' ' || $this->line[$this->lineIndex] === "\t") {
            $whitespaceCount++;
            $this->lineIndex++;
        }
        
        $data[] = array('spacer', $whitespaceCount);

        $this->token = '';
    }
}
